
=head1 NAME

OpenTracing::Manual - A quick overview about Perl5 and OpenTracing



=head1 WARNING

The C<OpenTracing> module on CPAN is B<NOT COMPLIANT> with anything remotely to
L<OpenTracing.IO|https://opentracing.io> or the L<OpenTracing::Interface>.

B<DO NOT USE THE OPENTRACING PACKAGE>



=head1 DESCRIPTION

This Manual is a quick overview of what is available in Perl related to the
OpenTracing API related Interface Definition.

This manual targets three different audiences:

=over

=item Application developers and Devops

Those that want to add instrumentation and tracing to their appilication or
micro services.

=item Framework or Integration Developers

Those writing integrations for frameworks, such that those can easily extract
tracing information from incoming request or inject that into outgoing requests.

=item Tracing service Implementation providers

Those that want to have the Perl Implementation communicate with their tracing
service provider.

=back

Included is a list of Perl Modules and those that are on the horizon.



=head1 INTRODUCTION

From the OpenTracing IO website:

OpenTracing is comprised of an API specification, frameworks and libraries
that have implemented the specification, and documentation for the project.
OpenTracing allows developers to add instrumentation to their application code
using APIs that do not lock them into any one particular product or vendor.

Distributed tracing, also called distributed request tracing, is a method used
to profile and monitor applications, especially those built using a
microservices architecture. Distributed tracing helps pinpoint where failures
occur and what causes poor performance.

See also: L<OpenTracing Overview|https://opentracing.io/docs/overview/>.



=head1 THE MANUAL



=head2 For Application developers and Devops

=head3 Adding OpenTracing to your Application

From the point of view for application developers that want to add
instrumentation, most likely it is just a matter of adding the right plugin to
your framework or useragent.

    use YourFramework::Plugin::OpenTracing;
    #
    # use OPENTRACING_IMPLEMENTATION environment variable to select which.

This will bootstrap a Tracer Implementation, use
L<< C<extract_context>|OpenTracing::Interface::Tracer/"extract_context(-OPENTRACING_CARRIER_FORMAT-=>-$carrier-)" >> and
L<< C<start_active_span>|OpenTracing::Interface::Tracer/"start_active_span(-$operation_name,-%options-)" >>
with any already existing Tracer information.

If your microservices are 'small' and 'shallow' this might be just enough what
you need. However, you will only get tracer information on the level provided by
the plugin. That is, probably just one single rootspan. Some framework plugins
might add another layer on top of that rootspan, like a setup-span, a run-span,
a render-span, and a teardown-span.

Incase you want more detailed information, see the next.

=head3 Getting Access to the bootstrapped Tracer

To get access to the Tracer, there are two ways to do so:

    use OpenTracing::GlobalTracer qw/$TRACER/;
    #
    # which might be `undef` if not yet bootstrapped

Or use a more reliable way:

    use aliased OpenTracing::GlobalTracer;
    
    my $tracer = GlobalTracer->get_global_tracer;
    #
    # which will always return a tracer (or croak)

In the latter approach, it may return a L<OpenTracing::Implementation::NoOp> as
defined in the specs. But at least your application won't break because of some
badly bootstrapped tracer, and 'production' can continue running.

In the examples below, C<$TRACER> will be used, but you should have used the
class method to get one.

=head3 Use of Baggage Items for Request Parameters

During some setup-stage, add Baggage Items, using L<< set_baggage_item|
OpenTracing::Interface::Span/set_baggage_item(-$key-=>-$value-) >>

    my $customer_id = YourFramwork->request->query_param('customer_id);
        
    $TRACER
        ->get_active_span
        ->set_baggage_item( customer_id => $customer_id );

Those Baggage Items will be progressed into all descendent spans and delivered
to the Tracing Provider.

=head3 Manually adding Spans

If you like to get more detail, you can add more
L<Spans|OpenTracing::Interface::Span>. For simplicity, Spans do
live inside a L<Scope|OpenTracing::Interface::Scope>, handled by a
L<ScopeManager|OpenTracing::Interface::ScopeManager>. Starting a Span will
return a Scope. According to the spec, once finished the scope this Span lives
in, one needs to call L<< C<close>|OpenTracing::Interface::Scope/"close" >>.

    sub exciting_task {
        my $_scope = $TRACER->start_active_span( "exiting task" );
        
        ...
        
        $_scope->close;
        
        return
    }

This can be annoying and even terrible if there are multiple exit points, using
I<return early> concepts, or when bailing out halfway.

This being Perl, we can do better using L<OpenTracing::AutoScope>:

    use OpenTracing::AutoScope;
    
    sub exciting_task {
        OpenTracing::AutoScope->start_guarded_span;
        
        ...
        
        return
    }

See L<< C<start_active_span>|OpenTracing::Interface::Tracer/start_active_span(-$operation_name,-%options-) >>
for all the options you can pass in.



=head2 For Framework or Integration Developers

Most of the time, a framework will have some sort of architecture that allows to
add plugins into the framework itself. These plugins, conveniently, bootstrap a
specific Implementation, but those backends should be easilly swapped, without
having too much impact on the code itself. All calls should follow the API.

Any framework plugin has the following responsabillities:

=over

=item Bootstrap a implenetation and GlobalTracer

=item Extracting posible exisitng trace information to create a Context

=back

On the otherhand, on the outgoing side of the server, the responsabillity is to:

=over

=item Inject the current Context into a 'Carrier'

=back

=head3 Bootstrap a Implementation

Plugins should either use a generic way to bootstrap a implementation or tailord
for just one implementation.

    use MyFramework::Plugin::OpenTracing;
    #
    # Bootstrap implementation from the `OPENTRACING_IMPLEMENTATION`
    # environment variable

or specifying it on the C<use> statement

    use MyFramework::Plugin::OpenTracing ( 'SomeImplementation',
        option => 'foo'
    );

or having a tailord plugin:

    use MyFrameWork::Plugin::OpenTracing::SomeImplementation;

But the latter approach requires writing multiple modules or subclasses.

Whatever way you choose, the responsabillity of the Framework Plugin is to set
the L<OpenTracing::GlobalTracer> such that it can be used inside the
application.

    use OpenTracing::Implementation qw/SomeImplementation/;

Or a more verbose way:

    use OpenTracing::Implementation
    
    my $tracer = OpenTracing::Implementation->bootstrap_global_tracer(
        SomeImplementation,
        option_one => 'foo',
        option_two => 'bar',
    );

See L<OpenTracing::Implementation> for more on how to bootstrap.

=head3 OpenTracing Carriers

The OpenTracing specification requires a L<Tracer|OpenTracing::Interface::Tracer>
implementation to understand how a L<SpanContext|OpenTracing::Interface::SpanContext>
will be I<inject> into or I<extract> from a so called I<carrier> or I<request>.

The I<carrier formats> required are I<text>, I<http>, and I<binary>, but there
is no I<standard> on how thoses formats exactly look like and are implementation
dependent.

For the time being, with this Perl implementation and definition, only
L<HTTP::Headers> will be used as a carrier. But once more, there is no
definition on what HTTP Header information is used and how it is formatted.

The L<HTTP::Headers> object is most common in Perl programming, and other
variants like L<HTTP::Headers::Fast> or L<HTTP:::Headers::Fast::XS> share the
same public interface. Most frameworks know how to handle those.

=head3 Extracting Context from an Incoming Request

    my $http_headers = YourFramework->request->headers;
    #
    # as long as this is a HTTP::Headers object
    
    my $root_context = $TRACER->extract_context(
        OPENTRACING_CARRIER_FORMAT_HTTP_HEADERS => $http_headers
    );

All Spans are part of a context. That is also true for the rootspan in a
Framework. Spans are started as a C<child_of> a specific L<SpanContext|OpenTracing::Interface::SpanContext>.

The SpanContext for a root-span is the incomming request that may or may not
contain tracer information from its requestor. Use the L<< C<extract_context>
from a I<Tracer> object|OpenTracing::Interface::Tracer/"extract_context(-OPENTRACING_CARRIER_FORMAT-=>-$carrier-)" >


Since some implementations may use inmutable objects and may have required
attributes for a L<SpanContext|OpenTracing::Interface::SpanContext> and since
the entire API is being accessed through the
L<Tracer|OpenTracing::Interface::Tracer> object, you may need to use I<builders>
as part of the attributes. Such builders can bridge the gap between the
framework and the implementation like so at initialisation time:

    $TRACER->set_default_context_builder sub {
        my $service_url = YourFramework->request->url;
        my $service_type = 'WEB',
        
        return {
            tracer_service_endpoint => $service_url,
            trecer_service_type     => $service_type,
        }
    };

And as such the returned hashreference might be merged with extracted tracerinfo
and used to create a complete L<SpanContext|OpenTracing::Interface::SpanContext>
object.

But remember, such mechanisms are entirely dependent on the implmentation.

=head3 Inject Context into an Outgoing Request

    my $span_context = $TRACER->get_active_span->get_context;
    
    use HTTP::Headers;
    my $http_headers = HTTP::Headers->new( ... );
    
    my $cntx_headers =
        $tracer->inject_context(
            OPENTRACING_FORMAT_HTTP_HEADERS => $http_headers,
            $opentracing_spancontext
    );
    
    my $request = HTTP::Request->new(
        GET => 'https://...', $cntx_headers
    );
    my response = LWP::UserAgent->request( $request );

=head3 Testing your Framework Plugins

To test that your Framework Plugin is doing the right thing, all you need to do
is run it with the L<Test Implementation|OpenTracing::Implementation::Test>. And
then compare the collected span information using
L<< C<globaltracer_cmp_deeply>|Test::OpenTracing::Integration >>
with a expected C<bag> of L<Span|OpenTracing::Interface::Span>s.

    use Test::Most;
    use Test::OpenTracing::Integration;
    
    my $test_application = Test::Application->new;
    my $http_request = HTTP::Request->new( ... );
    
    lives_ok{ $test_application->execute_request( $http_request );
    } "Can do request";
    
    globaltracer_cmp_deeply [ ... ],
        "... and produced the expected spans";
    
    done_testing;
    
    package Test::Application;
    
    use YourFramework;
    
    use YourFramework::Plugin::OpenTracing qw/Test/
    
    sub execute_request { ... }

Crucial is that you use the L<Test Implementation|OpenTracing::Implementation::Test>.
This will keep an in-memmory recording of all spans and have a additional
L<< C<get_recorded_trace>|OpenTracing::Implementation::Test::Tracer> to get the
collected spans, which can be used to compare with expected spans.



=head2 For Tracing service Implementation providers



=head1 SEE ALSO



Please have a look at the following modules or distributions to get more
detailed information about all the puzzle pieces.



=head2 The OpenTracing API Specification

The specification itself, and related modules.

=over

=item L<OpenTracing::Interface>

The description of the interface.

=item L<OpenTracing::Types>

To make type-checking more easy.

=item L<OpenTracing::Implementation::NoOp>

Prevent applications from crashing.

=back



=head2 Frameworks and Integrating OpenTracing

Distributed Tracing is all about connecting services and microservices together,
the following modules will handle the edges of the application and services and
bootstrap tracer implementations.

=over

=item L<CGI::Application::Plugin::OpenTracing>

Auto generate root-span on newly started trace, and on top a setup-span, a
run-span and more.

=item L<CGI::Application::Plugin::OpenTracing::DataDog>

Take care of all the specifics for DataDog.
Comes bundled with L<CGI::Application::Plugin::OpenTracing>.

=back



=head2 Instrumenting a Application

Once an application is running and the framwork has taken care of most of the
bootstrapping, the following modules help to can more detailed spans.

=over

=item L<OpenTracing::GlobalTracer>

Get access to a bootstrapped implementation.

=item L<OpenTracing::AutoScope>

Finish a span after exiting a scope.

=back



=head2 Implementations

A list of various Implementations that are compliant with the OpenTracing API.

=over

=item L<OpenTracing::Implementation>

Bootstrap an implementation and set a global tracer.

=item L<OpenTracing::Implementation::NoOp>

Prevent applications from crashing.

=item L<OpenTracing::Implementation::Test>

Build a data structure that can be used to do a C<cmp_deeply> variant.

=item L<OpenTracing::Implementation::DataDog>

Send traces and spans to the DataDog agent on the local host.

=back



=head2 Development and Testing

Modules that might be of interest when developping integrations or
implementations.

=over

=item L<OpenTracing::Implementation::Test>

Build a data structure that can be used to do a C<cmp_deeply> variant.

=item L<Test::OpenTracing>

Because we made mistakes.

=item L<Test::OpenTracing::Interface>

Check that the classes/objects adhere to the defined OpenTracing::Interface
description.

=item L<Test::OpenTracing::Integration>

Do a C<cmp_deeply> on a testing implementation.

=item L<OpenTracing::Roles>

A generic set of attributes and methods for building implementations.

=back



=head2 Planned work

The following modules will be needed for easier instrumentation of an
application or better framework integration and distributed tracing.

=over

=item L<OpenTracing::WrapScope>

Wrap full-qualified named subroutines in a scope, instead of modifying all the
codebase.

=item L<DBIx::OpenTracing>

Trace all C<DBI> requests, using L<DBIx::QueryLog>.

=item L<LWP::UserAgent::Plugin::OpenTracing>

OpenTracing C<inject_context> method for L<LWP::UserAgent>.

=item L<HTTP::Tiny::Plugin::OpenTracing>

OpenTracing C<inject_context> method for L<HTTP::Tiny>.

=item L<Plack::Middleware::OpenTracing>

OpenTracing C<extract_context> and create initial root-spans.

=item L<OpenTracing::HTTP::Headers>

Inject current `SpanContext`, a drop-in replacement, or even override
everywhere!.

=back



=head2 The Roadmap

Since all the work has been done for Peceptyx, no further development will be
done on the following, unless ...

Please contact the author!

=over

=item L<OpenTracing::Implementation::Zipkin>

See ... .

=item L<OpenTracing::Implementation::Elastic>

See ... .

=item L<OpenTracing::Implementation::Jaeger>

See ... .

=item L<OpenTracing::Implementation::XRay>

See ... .

=item L<OpenTracing::Implementation::NewRelic>

See L<New Relic APM|https://docs.newrelic.com/docs/apm>.

=item L<Dancer2::Plugin::OpenTracing>

See L<Dancer2::Plugin>.

=item L<Mojolicious::Plugin::OpenTracing>

See L<Mojolicious::Plugin>.

=item L<Catalyst::Plugin::OpenTracing>

See L<Catalyst>.

=item L<MooX::OpenTracing>

Get access to the L<OpenTracing::GlobalTracer> a la L<MooX::LogAny>.

=back



=head1 AUTHOR

Theo van Hoesel <tvanhoesel@perceptyx.com>

=head1 COPYRIGHT AND LICENSE

'OpenTracing API for Perl' is Copyright (C) 2019 .. 2020, Perceptyx Inc

This library is free software; you can redistribute it and/or modify it under
the terms of the Artistic License 2.0.

This library is distributed in the hope that it will be useful, but it is
provided "as is" and without any express or implied warranties.

For details, see the full text of the license in the file LICENSE.







